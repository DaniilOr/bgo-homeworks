# JOIN

При работе с SQL вы чаще всего будете сталкиваться с двумя видами объединений:
* `INNER JOIN`
* `LEFT JOIN`

Давайте на практике посмотрим, чем они отличаются.

Пусть у нас есть таблица `clients` вида (для простоты мы опустили "служебные" столбцы вроде `status` и `created`):

| id | name |
|---|---|
| 1 | Ivan Petrov |
| 2 | Vasiliy Ivanov |
| 3 | Darya Ivanova |

И таблица `transactions` следующего вида:

| id | amount | client_id |
|---|---|---|
| 1 | 1000 | 1 |
| 2 | 2000 | 1 |
| 3 | 20000 | 3 |

Обратите внимание: у Василия трат нет.

Соответственно, наша задача - сосчитать траты по каждому клиенту.

Начнём мы достаточно просто, просуммируем транзакции, сгруппировав по `client_id`:

```sql
SELECT sum(t.amount) total, t.client_id FROM transactions t GROUP BY t.client_id;
```

Мы намеренно сразу использовали псевдонимы таблицы, поскольку знаем, что будем использовать несколько таблиц.

В результате выполнения данного запроса мы получим следующее:

| total | client_id |
|---|---|
| 3000 | 1 |
| 20000 | 3 |

Теперь к этой таблице нужно "пристыковать" данные из таблицы `clients`. Но вот эта таблица, которую мы сейчас видели - её не существует в виде отдельной таблицы в БД. Это результаты (в виде таблицы), которые мы получили в результате выполнения запроса.

Но для SQL это не принципиально - мы можем результат запросе `SELECT` использовать как таблицу для выбора данных. Давайте начнём с тривиального сценария:

```sql
SELECT * FROM (SELECT sum(t.amount) total, t.client_id FROM transactions t GROUP BY t.client_id) transactions_stats;
```

| total | client_id |
|---|---|
| 3000 | 1 |
| 20000 | 3 |

Т.е. в `FROM` мы можем использовать в качестве источника данных - `SELECT`. Но результаты `SELECT` можно использовать не только в `FROM`, но и, например, в `JOIN` (что и поможет решить нам нашу задачу).

Теперь вернёмся к самой задаче: у нас есть таблица с пользователями и для каждого пользователя мы просто припишем сумму, зная о том, что сумму можно взять из результатов другого `SELECT`'а:

```sql
SELECT c.id, c.name, ts.total FROM clients c
JOIN (SELECT sum(t.amount) total, t.client_id FROM transactions t GROUP BY t.client_id) ts
ON c.id = ts.client_id;
```

| id | name | total |
|---|---|---|
| 1 | Ivan Petrov | 3000 |
| 3 | Darya Ivanova | 20000 |

И вроде всё отлично, да не совсем - Василия-то в отчёте нет. А нет его по одной простой причине - в "таблице" `transactions_stats` (результате запроса `SELECT`) не было найдено ни одной строки, соответствующей Василию (`ON c.id = ts.client_id`), поэтому она не попала в результирующий набор (т.к. СУБД не знает, что писать в столбец `total`).

Такое объединение называется `INNER JOIN`: в результирующий набор попадают только те строки из первой таблицы, которым нашлось соответствие во второй.

`INNER` подразумевается по умолчанию, поэтому может не писаться.

Но в реальном отчёте мы бы всё-таки хотели, чтобы Василий попал в итоговый отчёт. Но тогда что у него писать в столбце `total`? Вы, наверное, уже помните, что в SQL существует специальное значение `NULL`. 

Так вот существует объединение, которое позволяет выбрать все строки из первой таблицы, при этом:
1. Если для строки из первой таблицы есть соответствия из второй - то объединить их
1. Если для строки из первой таблицы нет соответствия из второй - то на месте отсутствующих столбцов записать `NULL`

Называется оно `LEFT OUTER JOIN`:

```sql
SELECT c.id, c.name, ts.total
FROM clients c
LEFT JOIN (SELECT sum(t.amount) total, t.client_id FROM transactions t GROUP BY t.client_id) ts
ON c.id = ts.client_id;
```

| id | name | total |
|---|---|---|
| 1 | Ivan Petrov | 3000 |
| 2 | Vasiliy Ivanov | &lt;null&gt; |
| 3 | Darya Ivanova | 20000 |

`OUTER` подразумевается по умолчанию, поэтому может не писаться.

Используя функцию `COALESCE` или подобные ей, мы можем `NULL` заменить на 0:

```sql
SELECT c.id, c.name, COALESCE(ts.total, 0) total
FROM clients c
LEFT JOIN (SELECT sum(t.amount) total, t.client_id FROM transactions t GROUP BY t.client_id) ts
ON c.id = ts.client_id;
```

| id | name | total |
|---|---|---|
| 1 | Ivan Petrov | 3000 |
| 2 | Vasiliy Ivanov | 0 |
| 3 | Darya Ivanova | 20000 |

Здесь стоит отметить, что мы лишь для примера привели объединение таблицы с результатами `SELECT`'а - то же самое было бы и для объединения обычных таблиц, объединения результатов двух `SELECT`'ов и т.д.

Ключевое: вы всегда должны думать об этом - должны ли в результаты попадать строки из первой таблицы, для которых не было соответствия во второй таблице.

Если не должны - то `INNER JOIN`, если должны - то `LEFT JOIN`.

P.S. Не забывайте, что при объединении формируется столько строк, сколько найдено соответствий - попробуйте объединить таблицу клиентов с таблицей их трат (без всяких агрегирующих функций), вы увидите, что для Ивана будет ровно две записи (по количеству транзакций):

```sql
SELECT c.id, c.name, t.amount FROM clients c
JOIN transactions t on c.id = t.client_id;
```

| id | name | total |
|---|---|---|
| 1 | Ivan Petrov | 1000 |
| 1 | Ivan Petrov | 2000 |
| 3 | Darya Ivanova | 20000 |

В данном конкретном случае, если сформулировать задачу "Для каждой транзакции указать владельца" мы сделали логически не правильно (хотя результат и получился правильным). При такой постановке стоит к таблице транзакций присоединять таблицу пользователей, а не наоборот (как сделали мы).
