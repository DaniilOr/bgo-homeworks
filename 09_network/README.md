# Домашнее задание к занятию «3.2. Работа с сетью, HTTP 1.1, HTTP 2»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **одном репозитории**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Export

На лекции мы с вами смотрели на то, как можно экспортировать данные в формат CSV. Но помимо CSV, вы ещё знаете про JSON и XML. Соответственно, ваша задача заключается в том, чтобы на базе кода с лекции сделать то же самое (экспорт) для JSON и XML.

По-хорошему, вам нужно сходить в RFC и поискать MIME типы для JSON и XML. Если вдруг так случилось, что вы их не нашли, то смотрите в подсказку.

<details>
<summary>MIME типы для JSON и XML</summary>

Content-Type:
* для JSON - `application/json` (или `application/json; charset=utf-8` - почему так, мы будем разбираться чуть позже)
* для XML - `application/xml`
</details>

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub (автотесты делать не нужно*).

Примечание*: мы отдельно будем разговаривать, как нужно будет делать автотесты на TCP и HTTP сервисы.

## Задача №2 – Медленные клиенты

Тот сервер, который мы написали на лекции, обладает одним фатальным недостатком - он не решает никак проблему медленных клиентов.

О чём идёт речь? Представим, что у нас есть клиент, который отправляет запрос со скоростью 1 байт в секунду. Поскольку наш сервер "однопоточный" (в единицу времени мы можем обрабатывать только одного клиента) то новых клиентов мы обрабатывать не сможем.

Давайте убедимся в этом, а потом вы исправите этот момент.

Писать мы будем по-прежнему на уровне TCP (обратите внимание, сервер должен быть запущен и работать):

```go
func main() {
	if err := execute(); err != nil {
		os.Exit(1)
	}
}

func execute() (err error) {
	conn, err := net.Dial("tcp", "localhost:9999")
	if err != nil {
		log.Println(err)
		return err
	}
	defer func(c io.Closer) {
		if cerr := c.Close(); cerr != nil {
			log.Println(cerr)
			if err == nil {
				err = cerr
			}
		}
	}(conn)

	request := []byte("GET / HTTP/1.1\r\n")
	for i := range request {
		time.Sleep(time.Second)
		part := request[i:i+1]
		log.Printf("write: %s", part)
		_, err = conn.Write(part)
		if err != nil {
			log.Println(err)
			return err
		}
	}
	log.Println("request finished")

	return nil
}
```

Теперь запустите ваш сервер и запустите клиент. У вас есть 16 секунд на то, чтобы в браузере вбить `http://localhost:9999` и увидеть, что браузер повиснет в режиме ожидания.

Это очень плохо. Поскольку если таких клиентов будет много, то у нас получится медленная очередь.

Самый первый вариант, который у нас есть (помимо "отстрела" медленных клиентов) - это использовать горутины для обработки подключающихся клиентов.

Вам достаточно проанализировать код веб-сервера с лекции и вынести обработку каждого подключающегося клиента в горутину. 

<details>
<summary>Подсказка</summary>

На самом деле, вам достаточно всего в одном месте поставить `go`.
</details>

Оформите данное улучшение в виде Pull Request'а к задаче №1.

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub (автотесты делать не нужно).
