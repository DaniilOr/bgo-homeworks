# Домашнее задание к занятию «2.3. Горутины и пакет sync»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия можно делать в **одном репозитории**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Сортировка

Эта задача не относится к горутинам, она относится только к замыканиям.

Суть заключается в следующем: достаточно часто пользователи хотят видеть отчёты сортируя покупки по стоимости.

Т.е. самая первая покупка - самая дорогая, потом чуть дешевле и т.д.

Мы хотим дать им такую возможность. У вас по-прежнему есть слайс из транзакций, с которым вы будете работать.

А для сортировки у нас есть пакет `sort` с замечательными функциями `Slice` и `SliceStable` (почитайте, чем они отличаются - это интересно, если коротко - то `SliceStable` гарантирует вам одинаковый порядок, что вам пригодится в тестах).

Обе имеют вот такой вид:
```go
func Slice(slice interface{}, less func(i, j int) bool) {
    ...
}
```

Давайте разбираться:
1. `slice interface{}` - это значит, что сортировать вы можете что угодно
2. `less func(i, j int) bool` - это значит, что вы должны передать функцию, которая отвечает на вопрос "верно ли, что `i`-ый элемент в слайсе меньше, чем `j`". Т.е. это именно индексы в слайсе

Функция это достаточно умная, вы ей показываете как сравнивать два элемента из слайса, а дальше она сама.

В общем виде это выглядит примерно вот так:

```go
sort.Slice(transactions, func(i, j int) bool {
    // можете использовать transactions[i] и transactions[j]
})

// в этой точке transactions уже отсортирован
```

По умолчанию, эта функция сортирует по возрастанию (т.е. от меньшего к большему), вам же надо в другую сторону.

<summary>
    <details>Подсказка</details>
    
    Возможно, стоит просто возвращать true вместо false и наоборот
</summary>

Для автотестов используйте следующий шаблон:
```go
for _, tt := range tests {
    if got := Sort(tt.args.transactions); !reflect.DeepEqual(tt.args.transactions, tt.want) {
        t.Errorf("Sum() = %v, want %v", got, tt.want)
    }
}
```

Почему именно так: в Go нельзя сравнивать слайсы с помощью ==. Но есть `reflect.DeepEqual`, которая хоть и медленная, но умеет сравнивать любые типы, включая сравнение их полей и т.д. Её мы и будем использовать.

Альтернативой является написание собственной вспомогательной функции, определяющей равенство слайсов (цикл + поэлементная проверка).

**Важно**: если вы используете `reflect.DeepEquals`, то используйте `SliceStable`.

Итого, у вас должно быть: оформленный проект с пакетами и автотестами, выложенный в репозиторий на GitHub и автотесты.

## Задача №2 – Сумма по месяцам

### Легенда

Эта задача является усложнённым вариантом той задачи, что мы решали на лекции. Единственное, что считать вам предстоит не общую сумму, а сумму по месяцам календарного года.

Что это значит? Это значит, что вы должны делить слайс с транзакциями не по количеству элементов, а по их дате.

Для того, чтобы задать границы, вам потребуется пакет `time`:

```go
// 01.01.2020 00:00 в локальном часовом поясе
t := time.Date(2020, 01, 01, 00, 0, 0, 0, time.Local) // Time
unix := t.Unix() // int64
```

Здесь есть важный нюанс, связанный со временем. Время клиента может отличаться от времени банка (например, в некоторых городах +2ч к Москве, а значит транзакция, которую он совершил 1 января 2020 в 00:00 по своему времени будет по Московскому времени ещё в 2019 году).

Соответственно, у вас есть два варианта:
1. Показывать в фиксированном часовом поясе (например, по Москве)
1. Показывать во времени клиента

Яркий пример второго варианта - мессенджеры, вы можете быть в разных часовы поясах, но присылаемые сообщения показываются вам вашим временем, а не временем отправителя. Ему же показываются в его времени.

Соответственно, вам нужно разделить всё по месяцам и расчёт каждого месяца запустить в отдельной горутине.

Складывать ничего не нужно, просто выводите в терминал:
```go
func SumConcurrently(transactions []int64, goroutines int) int64 {
	wg := sync.WaitGroup{}
	wg.Add(goroutines)

	total := int64(0)
	partSize := // TODO: решаете сами
	for i := 0; i < goroutines; i++ {
		part := transactions[i*partSize : (i+1)*partSize]
		go func() {
            sum := Sum(part)
			fmt.Println(sum)
			wg.Done()
		}()
	}

	wg.Wait()
	return total
}
```

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub.

Автотесты писать не нужно.

## Задача №3 – Типичная ошибка

### Легенда

Мы по-прежнему работаем с транзакциями (как на лекции, только вам нужно оформлять транзакции не в виде чисел, а в виде структур, как вы делали в предыдущих ДЗ).

На лекции мы с вами рассматривали вот такой пример:

```go
func SumConcurrently(transactions []int64, goroutines int) int64 {
	wg := sync.WaitGroup{}
	wg.Add(goroutines)

	total := int64(0)
	partSize := len(transactions) / goroutines
	for i := 0; i < goroutines; i++ {
		part := transactions[i*partSize : (i+1)*partSize]
		go func() {
			total += Sum(part) // FIXME: shared memory bug, discuss later
			wg.Done()
		}()
	}

	wg.Wait()
	return total
}
```

Мы его немного модернизируем, чтобы не было ошибки о которой написано в FIXME (об этом будет следующая лекция):

```go
func SumConcurrently(transactions []int64, goroutines int) int64 {
	wg := sync.WaitGroup{}
	wg.Add(goroutines)

	total := int64(0)
	partSize := len(transactions) / goroutines
	for i := 0; i < goroutines; i++ {
		part := transactions[i*partSize : (i+1)*partSize]
		go func() {
            sum := Sum(part)
            atomic.AddInt64(&total, sum)
			wg.Done()
		}()
	}

	wg.Wait()
	return atomic.LoadInt64(&total)
}
```

Так вот в чём вопрос: один из ваших товарищей сказал вам, что переменная `part` лишняя, можно написать просто вот так:
```go
func SumConcurrently(transactions []int64, goroutines int) int64 {
	wg := sync.WaitGroup{}
	wg.Add(goroutines)

	total := int64(0)
	partSize := len(transactions) / goroutines
	for i := 0; i < goroutines; i++ {
		go func() {
            sum := Sum(transactions[i*partSize : (i+1)*partSize]) // <--
            atomic.AddInt64(&total, sum)
			wg.Done()
		}()
	}

	wg.Wait()
	return atomic.LoadInt64(&total)
}
```

На самом деле, это неправильно. Всё дело в том, что значения "замкнутых" переменных вычисляются в момент вызова функции (т.е. когда эта функция запустится на исполнение).

Можете ради интереса поставить `fmt.Println(i)` и убедиться, что в некоторых запусках `i` будет дублироваться:
```go
func SumConcurrently(transactions []int64, goroutines int) int64 {
	wg := sync.WaitGroup{}
	wg.Add(goroutines)

	total := int64(0)
	partSize := len(transactions) / goroutines
	for i := 0; i < goroutines; i++ {
		go func() {
            fmt.Println(i)
            sum := Sum(transactions[i*partSize : (i+1)*partSize]) // <--
            atomic.AddInt64(&total, sum)
			wg.Done()
		}()
	}

	wg.Wait()
	return atomic.LoadInt64(&total)
}
```

Решения тут два:
1. То, которое мы рассмотрели на лекции: создавать `part` внутри цикла
1. Передавать аргументом в вызываемую функцию (т.к. аргументы вычисляются сразу):
```go
func SumConcurrently(transactions []int64, goroutines int) int64 {
	wg := sync.WaitGroup{}
	wg.Add(goroutines)

	total := int64(0)
	partSize := len(transactions) / goroutines
	for i := 0; i < goroutines; i++ {
		go func(part []int64) { <--
            sum := Sum()
            atomic.AddInt64(&total, sum)
			wg.Done()
		}(transactions[i*partSize : (i+1)*partSize]) <--
	}

	wg.Wait()
	return atomic.LoadInt64(&total)
}
```

Если вам сложно с такими большими кусками кода, то сравните вот такие три цикла:
```go
    // bad
	for i := 0; i < 100; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
 
    // ok
	for i := 0; i < 100; i++ {
		j := i
		go func() {
			fmt.Println(j)
		}()
	}

    // ok
	for i := 0; i < 100; i++ {
		go func(j int) {
			fmt.Println(j)
		}(i)
	}
```

Так что же нужно сделать? Напишите автотесты на все три варианта, которые бы показывали, что вариант, предложенный вашим коллегой-оптимизатором, не правильный.

Сразу скажем, что слайс со всеми единицами уже не подойдёт.

<summary>
    <details>Подсказка</details>
    
    Возможно, стоит сделать "части" отличающимися по сумме, например, в первой части у всех транзакций стоимость будет 1, во второй - 2 и т.д.
    
    Может это как-то снизит вероятность того, что при неправильном `i` в замыкании общая сумма не сойдётся? 
</summary>

Итого, у вас должно быть: оформленный проект с пакетами и автотестами, выложенный в репозиторий на GitHub.


Один тест должен падать, показывая, что идеи вашего коллеги не верны.
