# Домашнее задание к занятию «1.3. Структуры, указатели, массивы, slices, maps»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **одном репозитории**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (читайте в [инструкции по установке Go и GoLand](../installation.md))
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Транзакции

### Легенда

Каждый раз, когда клиент совершает покупки, в историю транзакций попадает соответствующая запись:

Что вам нужно сделать:
1. Создайте новый тип `Transaction` внутри пакета `card` с нужными полями: пусть id пока будет `int64`, нам также понадобится сумма транзакции, дата в формате unix timestamp* и код MCC (`string`*)
1. Создайте внутри типа `Card` поле `transactions`, в котором будет слайс из транзакций (достаточно его объявить вот так: `transactions: []Transaction`)

А теперь самое интересное: как добавлять транзакцию в карту?

Первое, что у нас есть - это функция `append` (built-in функция):

```go
func append(slice []Type, elems ...Type) []Type
```

Работает она следующим образом: если слайс `slice` имеет достаточную ёмкость (`capacity`) для того, чтобы уместить все добавляемые элементы `elems`, то элементы добавляются в этот слайс. Если же нет, то создаётся новый слайс, под него выделяется массив и всё складывается туда.

Именно поэтому функция возвращает вам новый слайс.

Запись `elems ...Type` означает в данном случае variadic-функцию. Это значит, что мы можем передавать туда произвольное количество аргументов через запятую:

```go
visa.transactions = append(visa.transactions, foodTransaction, serviceTransaction)
```

Обратите внимание, мы всегда присваиваем результат `append` в то поле (или переменную), в котором до этого хранился исходный слайс, потому что в результате работы функция `append` может выделить новый массив.

## Задача №2 - Категории расходов

### Легенда

