# Домашнее задание к занятию «3.3. HTTP: разработка клиента и интеграция со сторонними сервисами»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **разных репозиториях**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Удостоверьтесь, что вы правильно отформатировали файлы (см. раздел Форматирование из [первого ДЗ](../01_std))
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Курс Валют

[ЦБ РФ](https://www.cbr.ru/) предоставляет [бесплатные сервисы](https://www.cbr.ru/development/SXML/).

Среди указанных сервисов, есть сервис, позволяющий получить курс валют: http://www.cbr.ru/scripts/XML_daily.asp

Но, к сожалению, этот сервис возвращает ответ в кодировке cp1251, а с кодировками мы работать ещё не умеем.

Поэтому мы для вас подготовили статичную версию - вам нужно загружать данные методом GET по адресу: https://raw.githubusercontent.com/netology-code/bgo-homeworks/master/10_client/assets/daily.xml

Информация приходит вот в таком виде:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<ValCurs Date="14.07.2020" name="Foreign Currency Market">
    <Valute ID="R01010">
        <NumCode>036</NumCode>
        <CharCode>AUD</CharCode>
        <Nominal>1</Nominal>
        <Name>Австралийский доллар</Name>
        <Value>49.2547</Value>
    </Valute>
    <Valute ID="R01020A">
        <NumCode>944</NumCode>
        <CharCode>AZN</CharCode>
        <Nominal>1</Nominal>
        <Name>Азербайджанский манат</Name>
        <Value>41.6409</Value>
    </Valute>
    <Valute ID="R01035">
        <NumCode>826</NumCode>
        <CharCode>GBP</CharCode>
        <Nominal>1</Nominal>
        <Name>Фунт стерлингов Соединенного королевства</Name>
        <Value>89.1990</Value>
    </Valute>
    <Valute ID="R01060">
        <NumCode>051</NumCode>
        <CharCode>AMD</CharCode>
        <Nominal>100</Nominal>
        <Name>Армянских драмов</Name>
        <Value>14.5303</Value>
    </Valute>
    <Valute ID="R01090B">
        <NumCode>933</NumCode>
        <CharCode>BYN</CharCode>
        <Nominal>1</Nominal>
        <Name>Белорусский рубль</Name>
        <Value>29.2540</Value>
    </Valute>
</ValCurs>
```

Обратите внимание на то, что номинал не всегда равен 1

Мы вам говорили, что хранения в копейках достаточно для большинства случаев, но вот для обмена валют - уже нет. Поэтому придётся в данном случае использовать `float64` (со всеми вытекающими).

Вам нужно оформить всё в соответствии со стандартной схемой - выделить сервис и метод в нём (давайте назовём его `Extract`). Задача этого метода - скачивать файл xml, преобразовывать его в json и сохранять в файловой системе в текущем рабочем каталога в файл `currencies.json`*.

Примечание*: не обязательно всё делать в одном методе, вы можете выделить вспомогательные (неэкспортируемые методы, которые возьмут на себя часть задач).

Интеграция - всегда процесс сложный, поэтому мы пойдём с вами по простому пути:
1. Для `Unmarshal`'инга xml вы создадите структуру
1. Для хранения данных внутри приложения вы создадите структуру, в которой будут поля: `Code` (код валюты - строка), `Name` (название - строка), `Value` - стоимость **единицы** в рублях.
1. Для `Marshal`'инга в json придётся создать ещё одну структуру (не стоит совмещать DTO и модели внутреннего представления данных) с json-тегами `code`, `name` и `value` соответственно.

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub (автотесты делать не нужно).

## Задача №2 - QR Code

QR-коды по-прежнему достаточно широко используются в нашем окружении.

Например, тот же Банк Тинькофф выдаёт по QR-кода деньги из банкомата.

Конечно, мы можем изучить как генерируются подобные коды и даже сами что-то написать, но это будет очень долго. Почему бы не взять готовую реализацию (например, библиотеку), а ещё лучше - готовый веб-сервис. Пусть этот веб-сервис поддерживает кто-то другой, наша же задача - быть пользователями (это мы потихоньку переходим в сфере микросервисов).

Сервис http://goqr.me предоставляет API для генерации QR кодов. Конечно же, в промышленных решениях вы не будете использовать неизвестный вам сервис и, скорее всего, напишите свой. Но сейчас для нас - это самое то.

Всё, что нужно сделать - это отправить соответствующий HTTP-запрос на сервер. В ответ нам придёт изображение. А поскольку изображение (как вы уже знаете) - это просто набор байт, то мы можем сохранить этот набор байт в файл с нужным расширением (вспомните про `Content-Type` или почитайте документацию на сам сервис).

Вам нужно изучить документацию по адресу: http://goqr.me/api/doc/create-qr-code/ и написать сервис, который на вход принимает строку, которую нужно закодировать, и название файла, в который нужно записать получившийся QR-код.

Помимо всего прочего, в этой задаче нужно использовать `Context` с таймаутом (т.е. если удалённый сервер не ответил за нужное время, работа должна завершаться).

Таймаут должен определяться через переменную окружения и быть в миллисекундах.

Когда будете тестировать, выставляйте маленький таймаут (в несколько десятков миллисекунд), чтобы удостовериться, что он действительно срабатывает.

Запуск метода сервиса осуществляйте в `main`:
```go
// файл main.go
func main() {
    // TODO: получить данные из переменных окружения
    ctx, _ := context.WithTimeout(context.Background(), timeout)
    svc := qr.NewService()
    data, filetype, err := svc.Encode(ctx, data)
    // TODO: handle err & write data to file
}
```

Основная сложность - продумать, что должен возвращать метод `Encode`. Это мы оставляем на ваше усмотрение.

Итого, у вас должно быть: оформленный проект с пакетами, выложенный в репозиторий на GitHub (автотесты делать не нужно).
